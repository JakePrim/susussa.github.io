<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Prim博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sufulu.top/"/>
  <updated>2018-02-03T09:56:02.895Z</updated>
  <id>http://www.sufulu.top/</id>
  
  <author>
    <name>Prim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解链表和手写链表以及面试中常问链表的问题</title>
    <link href="http://www.sufulu.top/2018/02/03/%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.sufulu.top/2018/02/03/链表/</id>
    <published>2018-02-03T07:42:38.000Z</published>
    <updated>2018-02-03T09:56:02.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>上一期 讲到了 <a href="http://www.sufulu.top/2018/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/">顺序表与链表的基本知识</a> 了解链表的基本知识。并且分析了ArrayList的源码。顺序表(随机访问速度快，插入和删除效率低)和链表(随机访问速度慢，插入和删除效率高)的优缺点。在开始写双链表之前我们分析一下LinkedList(典型的双链表)源码，来看一下Java 中是如何实现双链表的。</p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-c642dc23da016b45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双链表"><br><a id="more"></a> </p><h4 id="LinkedList-源码解析"><a href="#LinkedList-源码解析" class="headerlink" title="LinkedList 源码解析"></a>LinkedList 源码解析</h4><p>在分析一个类时，首先分析类的继承关系，再分析构造方法和属性。</p><h5 id="LinkedList-继承关系"><a href="#LinkedList-继承关系" class="headerlink" title="LinkedList 继承关系"></a>LinkedList 继承关系</h5><blockquote><p>public class LinkedList<e> extends AbstractSequentialList<e><br>implements List<e>, Deque<e>, Cloneable, java.io.Serializable</e></e></e></e></p></blockquote><ol><li>LinkedList 继承 AbstractSequentialList,而  AbstractSequentialList<e> extends AbstractList<e> 在上一期中 ArrayList 继承AbstractList ，AbstractSequentialList 它实现了list 的一些位置相关的操作。</e></e></li><li>实现list 接口能对它进行队列操作。</li><li>Deque双端队列，双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两邊进行</li><li>Cloneable 覆盖了函数clone()</li><li>Serializable 支持序列化，能通过序列化传输数据</li></ol><h5 id="LinkedList-属性"><a href="#LinkedList-属性" class="headerlink" title="LinkedList 属性"></a>LinkedList 属性</h5><blockquote><p>关键字transient 标识的字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。<br>我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列<br>化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Seril<br>izable接口，这个类的所有属性和方法都会自动序列化。<br>然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属<br>性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安<br>全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信<br>息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存<br>中而不会写到磁盘里持久化。<br>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要<br>序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目<br>的地中。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">transient int size = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Pointer to first node.</span><br><span class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line"> *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Pointer to last node.</span><br><span class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line"> *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>每个节点都是存储对象Node，包括(E item;Node<e> next;Node<e> prev;)这就意味着LinkedList 占用的内存会比较大,ArrayList 只包括 E,LinkedList 比ArrayList 占用内存大</e></e></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">       //当前节点的 item</span><br><span class="line">       E item;</span><br><span class="line">       //表示 当前节点的下一个节点</span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line">       //表示 当前节点的上一个节点</span><br><span class="line">       Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           this.item = element;</span><br><span class="line">           this.next = next;</span><br><span class="line">           this.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="LinkedList-构造方法"><a href="#LinkedList-构造方法" class="headerlink" title="LinkedList 构造方法"></a>LinkedList 构造方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Constructs an empty list.</span><br><span class="line">    */</span><br><span class="line">   public LinkedList() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Constructs a list containing the elements of the specified</span><br><span class="line">    * collection, in the order they are returned by the collection&apos;s</span><br><span class="line">    * iterator.</span><br><span class="line">    *</span><br><span class="line">    * @param  c the collection whose elements are to be placed into this list</span><br><span class="line">    * @throws NullPointerException if the specified collection is null</span><br><span class="line">    */</span><br><span class="line">   public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       this();</span><br><span class="line">       addAll(c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>LinkedList 有两个构造方法，第一个就不必说了，第二个构造一个链表，传入的是一个list(interface List<e> extends Collection<e>)<br>addAll(c) 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       return addAll(size, c);</span><br><span class="line">   &#125;</span><br><span class="line"> public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">      //判断 index &gt;= 0 &amp;&amp; index &lt;= size;</span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line">       //将list 转换成一个数组 </span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       int numNew = a.length;</span><br><span class="line">       //若数组的长度为0 返回false 不能构造链表</span><br><span class="line">       if (numNew == 0)</span><br><span class="line">           return false;</span><br><span class="line"></span><br><span class="line">       Node&lt;E&gt; pred, succ;</span><br><span class="line">       //若插入的位置 == 链表的大小</span><br><span class="line">       if (index == size) &#123;</span><br><span class="line">           succ = null;</span><br><span class="line">           //准备要插入的节点 == last 链表的最后一个节点，准备循环从最后一个节点添加</span><br><span class="line">           pred = last;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            //若插入的位置 ！= 链表的大小 找到要插入的位置</span><br><span class="line">           succ = node(index);</span><br><span class="line">           //准备插入的节点 == 插入位置的前一个节点</span><br><span class="line">           pred = succ.prev;</span><br><span class="line">       &#125;</span><br><span class="line">       //循环数组中的Object 创建Node 节点</span><br><span class="line">       for (Object o : a) &#123;</span><br><span class="line">           @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</span><br><span class="line">           //创建新的节点Node</span><br><span class="line">           Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</span><br><span class="line">           //若准备插入的节点为null 说明 index == size 而 pred = last链表为空</span><br><span class="line">           if (pred == null)</span><br><span class="line">               first = newNode;</span><br><span class="line">           else</span><br><span class="line">               pred.next = newNode;</span><br><span class="line"></span><br><span class="line">           pred = newNode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //succ == null 说明 index == size</span><br><span class="line">       if (succ == null) &#123;</span><br><span class="line">           last = pred;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           pred.next = succ;</span><br><span class="line">           succ.prev = pred;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       size += numNew;</span><br><span class="line">       modCount++;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></e></e></p><h5 id="LinkedList-添加节点"><a href="#LinkedList-添加节点" class="headerlink" title="LinkedList 添加节点"></a>LinkedList 添加节点</h5><p><img src="http://upload-images.jianshu.io/upload_images/2005932-d8547c0e6e3aabb2.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双向链表插入.JPG"></p><ol><li><p>add(E e) 尾部插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">       linkLast(e);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Links e as last element.</span><br><span class="line">    */</span><br><span class="line">   void linkLast(E e) &#123;</span><br><span class="line">       //尾部节点</span><br><span class="line">       final Node&lt;E&gt; l = last;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">       //尾部 == 新的节点</span><br><span class="line">       last = newNode;</span><br><span class="line">       //注意判断尾部是否为空，若尾部last为空 则说明链表为空</span><br><span class="line">       if (l == null)</span><br><span class="line">           //第一个节点 == newNode</span><br><span class="line">           first = newNode;</span><br><span class="line">       else</span><br><span class="line">           //之前的尾部节点的next 指向新添加的节点</span><br><span class="line">           l.next = newNode;</span><br><span class="line">       //链表大小加一</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>add(int index, E element) 中间插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">       //插入的位置必须&gt;=0 并且 &lt;= size</span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line">       </span><br><span class="line">       //尾部插入</span><br><span class="line">       if (index == size)</span><br><span class="line">           linkLast(element);</span><br><span class="line">       else</span><br><span class="line">           //中间插入 首先找到插入位置的节点</span><br><span class="line">           linkBefore(element, node(index));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">       // assert succ != null;</span><br><span class="line">       //插入位置的节点的前一个节点</span><br><span class="line">       final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">       //new 要插入的节点 </span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">       succ.prev = newNode;</span><br><span class="line">       if (pred == null)</span><br><span class="line">           first = newNode;</span><br><span class="line">       else</span><br><span class="line">           pred.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">       // assert isElementIndex(index);</span><br><span class="line">       //插入的位置 &lt; 链表大小的一半 则从左侧  first 节点查找</span><br><span class="line">       if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           for (int i = 0; i &lt; index; i++)</span><br><span class="line">               x = x.next;</span><br><span class="line">           return x;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           //插入的位置 &gt; 链表大小的一半则从右侧  last 节点查找</span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">               x = x.prev;</span><br><span class="line">           return x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="LinkedList-删除节点"><a href="#LinkedList-删除节点" class="headerlink" title="LinkedList 删除节点"></a>LinkedList 删除节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        //要删除某个节点 同样要找到该位置的节点</span><br><span class="line">        return unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        // assert x != null;</span><br><span class="line">        final E element = x.item;</span><br><span class="line">        final Node&lt;E&gt; next = x.next;</span><br><span class="line">        final Node&lt;E&gt; prev = x.prev;</span><br><span class="line">        </span><br><span class="line">        //删除的节点前一个为空 则说明删除的是第一个节点</span><br><span class="line">        if (prev == null) &#123;</span><br><span class="line">            //第一个节点first = 删除节点的下一个节点</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //删除的节点前一个不为空 删除节点的前一个节点的next </span><br><span class="line">            //指向删除节点的下一个节点</span><br><span class="line">            prev.next = next;</span><br><span class="line">            //将删除节点 prev 置为null</span><br><span class="line">            x.prev = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">        //将删除节点的item 置为null</span><br><span class="line">        x.item = null;</span><br><span class="line">        //链表减一</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        return element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="LinkedList-查找节点"><a href="#LinkedList-查找节点" class="headerlink" title="LinkedList 查找节点"></a>LinkedList 查找节点</h5><p>查找节点为耗时较长，算法复杂度为 o(n) = n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">      // assert isElementIndex(index);</span><br><span class="line">      //插入的位置 &lt; 链表大小的一半 则从左侧  first 节点查找</span><br><span class="line">      if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">          Node&lt;E&gt; x = first;</span><br><span class="line">          for (int i = 0; i &lt; index; i++)</span><br><span class="line">              x = x.next;</span><br><span class="line">          return x;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          //插入的位置 &gt; 链表大小的一半则从右侧  last 节点查找</span><br><span class="line">          Node&lt;E&gt; x = last;</span><br><span class="line">          for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">              x = x.prev;</span><br><span class="line">          return x;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="链表总结"><a href="#链表总结" class="headerlink" title="链表总结"></a>链表总结</h4><blockquote><p>从上述分析我们可以得出，链表(LinkedList)的尾插效率高，中间插入和删除算法复杂度为 o<br>(n) = n,对比顺序表（ArrayList ）插入删除都用到了复制System.arraycopy(<br>elementData, index, elementData, index + 1,size - index);<br>算法复杂度要比双链表的插入和删除复杂度高。如果频繁的插入和删除操作建议用链表的存储结构；<br>如果要想快速的查找到某条数据建议用顺序表的存储结构。</p></blockquote><h3 id="手写双链表"><a href="#手写双链表" class="headerlink" title="手写双链表"></a>手写双链表</h3><p>如何手写一个双链表，我们可以仿照LinkedList 的源码写一个简单的双链表</p><p>首先双链表的模型类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    Node next;</span><br><span class="line">    Node per;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int size;</span><br><span class="line">Node frist;</span><br><span class="line">Node last;</span><br></pre></td></tr></table></figure></p><p>Node静态类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            this.item = element;</span><br><span class="line">            this.next = next;</span><br><span class="line">            this.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>完整的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt; &#123;</span><br><span class="line">    public LinkedList() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; frist;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    int size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向链表的尾部添加一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param e</span><br><span class="line">     */</span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(int index, E e) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; size) return;</span><br><span class="line"></span><br><span class="line">        if (index == size) &#123;//插入尾部</span><br><span class="line">            linkLast(e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Node&lt;E&gt; currentNode = node(index);//拿到当前位置要插入的节点</span><br><span class="line">            Node&lt;E&gt; prev = currentNode.prev;</span><br><span class="line">            Node&lt;E&gt; newNode = new Node&lt;&gt;(prev, e, currentNode);</span><br><span class="line">            if (prev == null) &#123;//头部插入</span><br><span class="line">                frist = newNode;</span><br><span class="line">            &#125; else &#123;//中间插入</span><br><span class="line">                prev.next = newNode;//Note : 这里两个位置不能换</span><br><span class="line">            &#125;</span><br><span class="line">            currentNode.prev = newNode;//Note: 查到的节点prev 要指向新的节点</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; size) return;</span><br><span class="line">        unLinkNode(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void unLinkNode(Node&lt;E&gt; node) &#123;</span><br><span class="line">        Node&lt;E&gt; prev = node.prev;</span><br><span class="line">        Node&lt;E&gt; next = node.next;</span><br><span class="line">        if (prev == null)&#123;</span><br><span class="line">            frist = next;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            node.prev = null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (next == null)&#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            node.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">        size --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个节点的元素</span><br><span class="line">     *</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; size) return null;</span><br><span class="line">        return node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        if ((size &gt;&gt; 1) &lt; index) &#123;//从尾部开始循环</span><br><span class="line">            Node&lt;E&gt; node = last;</span><br><span class="line">            for (int i = size - 1; i &gt; index; i--) &#123;</span><br><span class="line">                node = last.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            return node;</span><br><span class="line">        &#125; else &#123;//从头部开始循环</span><br><span class="line">            Node&lt;E&gt; node = frist;</span><br><span class="line">            for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void linkLast(E e) &#123;</span><br><span class="line">        Node&lt;E&gt; newNode = new Node&lt;&gt;(last, e, null);</span><br><span class="line">        Node&lt;E&gt; l = last;//拿到之前的最后一个节点</span><br><span class="line">        last = newNode;//将添加的新节点newNode 赋给last 最后一个节点</span><br><span class="line">        if (l == null) &#123;//如果之前的最后一个节点为空</span><br><span class="line">            frist = newNode;</span><br><span class="line">        &#125; else &#123;//如果之前的最后一个节点不为空</span><br><span class="line">            l.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            this.item = element;</span><br><span class="line">            this.next = next;</span><br><span class="line">            this.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道如何写一个双链表，那么写一个单链表就更简单了。</p><h5 id="在面试中经常问到，如何将一个单链表逆置"><a href="#在面试中经常问到，如何将一个单链表逆置" class="headerlink" title="在面试中经常问到，如何将一个单链表逆置?"></a>在面试中经常问到，如何将一个单链表逆置?</h5><p>在实现逆置之前我们写一个单链表，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">public class SingleList&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        public Node(E item, Node&lt;E&gt; next) &#123;</span><br><span class="line">            this.item = item;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node&lt;E&gt; frist;</span><br><span class="line"></span><br><span class="line">    private Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    public int size;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向尾部添加一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param e</span><br><span class="line">     */</span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        lastList(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在某个位置插入一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param e</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public void add(E e, int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; size) return;</span><br><span class="line">        if (index == size) &#123;//插入尾部</span><br><span class="line">            lastList(e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (index == 0) &#123;</span><br><span class="line">                Node&lt;E&gt; l = frist;</span><br><span class="line">                Node&lt;E&gt; newNode = new Node&lt;&gt;(e, l);//新的元素在插入位置的前一个位置</span><br><span class="line">                frist = newNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Node&lt;E&gt; fNode = node(index - 1);//找到要插入位置的前一个位置</span><br><span class="line">                Node&lt;E&gt; lNode = fNode.next;</span><br><span class="line">                Node&lt;E&gt; newNode = new Node&lt;&gt;(e, lNode);</span><br><span class="line">                fNode.next = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除某个节点</span><br><span class="line">     *</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public void remove(int index) &#123;</span><br><span class="line">        unLink(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void unLink(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; size) return;</span><br><span class="line">        if (index == size) &#123;//删尾部</span><br><span class="line">            Node&lt;E&gt; node = node(index - 1);</span><br><span class="line">            node.next = null;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125; else if (index == 0) &#123;//删头部</span><br><span class="line">            Node&lt;E&gt; l = this.frist;</span><br><span class="line">            frist = l.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Node&lt;E&gt; node = node(index - 1);//要删除的前一个节点</span><br><span class="line">            Node&lt;E&gt; removeNode = node.next;//要删除的节点</span><br><span class="line">            Node&lt;E&gt; lNode = removeNode.next;//要删除的后一个节点</span><br><span class="line">            node.next = lNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove(E e) &#123;</span><br><span class="line">        Node&lt;E&gt; newNode = frist;</span><br><span class="line">        int index = -1;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">            if (e.equals(newNode.item)) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index != -1)</span><br><span class="line">            unLink(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void lastList(E e) &#123;</span><br><span class="line">        Node&lt;E&gt; newNode = new Node&lt;&gt;(e, null);//一个新的节点</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; l = last;</span><br><span class="line"></span><br><span class="line">        last = newNode;//将最后一个节点赋值</span><br><span class="line">        if (l == null) &#123;</span><br><span class="line">            frist = newNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取节点的某个元素</span><br><span class="line">     *</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; size) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        Node&lt;E&gt; newNode = frist;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试单链表的添加个删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  SingleList&lt;Integer&gt; singleList = new SingleList&lt;&gt;();</span><br><span class="line">        singleList.add(1);</span><br><span class="line">        singleList.add(2);</span><br><span class="line">        singleList.add(3);</span><br><span class="line">        singleList.add(4);</span><br><span class="line">        singleList.add(5);</span><br><span class="line">//        singleList.add(9,0);</span><br><span class="line">//        singleList.add(8,5);</span><br><span class="line">//        singleList.add(7,2);</span><br><span class="line">//        singleList.remove(6);</span><br><span class="line">//        singleList.remove(3);</span><br><span class="line">        for (int i = 0; i &lt; singleList.size; i++) &#123;</span><br><span class="line">            System.out.print(singleList.get(i) + &quot; &quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h6 id="如何实现逆置？"><a href="#如何实现逆置？" class="headerlink" title="如何实现逆置？"></a>如何实现逆置？</h6><p>第一种方法，循环法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 单链表的逆置</span><br><span class="line">   * 第一种方法实现 循环</span><br><span class="line">   */</span><br><span class="line">  public void inverse() &#123;</span><br><span class="line">      Node&lt;E&gt; l = this.last;</span><br><span class="line">      Node&lt;E&gt; curr = this.frist;</span><br><span class="line">      Node&lt;E&gt; reve = null;</span><br><span class="line">      while (curr != null) &#123;</span><br><span class="line">          Node&lt;E&gt; temp = curr;</span><br><span class="line">          curr = curr.next;</span><br><span class="line">          temp.next = reve;</span><br><span class="line">          reve = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      frist = reve;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-980cb8e79c6ff6bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如上图所示：<br>第一次循环后得到的 –》 temp = 1 curr =2 temp.next = null reve = temp = 1 ;链表的结构就变为 1 –&gt; null  2 –&gt; 3 –&gt; 4.<br>第二次循环后得到的 –》 temp = 2 curr = 3 temp.next = 1  reve = temp = 2 ;链表的结构就变为 2 –&gt; 1 –&gt; null  3 –&gt; 4<br>第三次循环后得到的 –》 temp = 3 curr = 4 temp.next = 2  reve = temp = 3 ;链表的结构就变为 3 –&gt; 2 –&gt; 1 –&gt; null   4<br>….<br>如此类推就可以得到一个逆置的单链表。</p><p>第二种方法，递归法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 递归的方式转置</span><br><span class="line">  */</span><br><span class="line"> public Node&lt;T&gt; reverse(Node&lt;T&gt; head) &#123;</span><br><span class="line">     if (head == null || head.next == null) &#123;</span><br><span class="line">         return head;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Node&lt;T&gt; tail = reverse(head.next);</span><br><span class="line">     head.next.next = head;</span><br><span class="line">     head.next = null;</span><br><span class="line">     return tail;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void transterReverse() &#123;</span><br><span class="line">     this.frist = reverse(this.frist);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-f6e8cfb604ec7393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如上图所示递归法的逆置逻辑：<br>1 –&gt; 2 –&gt; 3 &lt;– 4</p><p>1 –&gt; 2 &lt;– 3 &lt;–4</p><p>1 &lt;– 2 &lt;– 3 &lt;–4</p><p>至此，数据结构线性表的内容基本讲完。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;双链表&quot;&gt;&lt;a href=&quot;#双链表&quot; class=&quot;headerlink&quot; title=&quot;双链表&quot;&gt;&lt;/a&gt;双链表&lt;/h3&gt;&lt;p&gt;上一期 讲到了 &lt;a href=&quot;http://www.sufulu.top/2018/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/&quot;&gt;顺序表与链表的基本知识&lt;/a&gt; 了解链表的基本知识。并且分析了ArrayList的源码。顺序表(随机访问速度快，插入和删除效率低)和链表(随机访问速度慢，插入和删除效率高)的优缺点。在开始写双链表之前我们分析一下LinkedList(典型的双链表)源码，来看一下Java 中是如何实现双链表的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2005932-c642dc23da016b45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;双链表&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://www.sufulu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.sufulu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-线性表(顺序表与链表的基本知识 以及ArrayList 源码分析)</title>
    <link href="http://www.sufulu.top/2018/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://www.sufulu.top/2018/01/29/数据结构-线性表/</id>
    <published>2018-01-29T13:43:31.000Z</published>
    <updated>2018-02-03T07:54:20.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构之线性表"><a href="#数据结构之线性表" class="headerlink" title="数据结构之线性表"></a>数据结构之线性表</h1><p>在开始数据结构前，先了解什么是数据结构？数据结构 + 算法 = 程序</p><h2 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h2><blockquote><p>数据结构是对在计算机内存中的数据的一种安排。也可以理解为对计算机运算的数据单元的一个抽<br>象。也可以理解为数据结构是指在计算机内存空间中或磁盘中的组织形式。</p></blockquote><p>数据结构的定义描述的有些抽象，举个栗子：<br><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=120971917,3450162612&amp;fm=27&amp;gp=0.jpg" alt="举个栗子"><br><a id="more"></a><br>比如：美女和野兽，抽象的事物表示美女：头发长 前凸后翘。。。 可以表示为一个数据单元，野兽也是一个数据单元。<br>我们可以这样理解，数据结构是描述个体的数据集合，包含两者的关系，数据与数据之前的关系，逻辑的结构。<br>比如：在人机对弈中，棋盘、棋子、人 三者的关系，棋盘存储起来  棋子是个单独的数据 人是个对象 三者之间的关系，错综复杂的关系组合起来就是数据结构。</p><h3 id="数据结构的逻辑结构"><a href="#数据结构的逻辑结构" class="headerlink" title="数据结构的逻辑结构"></a>数据结构的逻辑结构</h3><ol><li>集合结构</li><li>线性结构</li><li>树形结构</li><li>图形结构</li></ol><h3 id="数据结构的存储结构"><a href="#数据结构的存储结构" class="headerlink" title="数据结构的存储结构"></a>数据结构的存储结构</h3><ol><li>表</li><li>堆栈</li><li>队列</li><li>数据</li><li>树</li><li>二叉树</li><li>图</li></ol><p>了解了数据结构的基本内容，我们下面开始正题。</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ol><li>顺序存储结构</li><li>链式存储结构</li></ol><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>顺序存储结构可以理解为：<br>种菜，比如种萝卜，一个萝卜一个坑，从第一个一直按顺序种到最后一个。<br>再比如我们去银行办理业务，都要先取号排队，一个号都对应着一个人。<br>前后相关联的</p><p>如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-7dcb210ddaf6d1ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>a1是a2的前驱，ai+1 是ai的后继，a1没有前驱，an没有后继<br>n为线性表的长度 ，若n==0时，线性表为空表.</p><p>顺序表的类模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Array &#123;</span><br><span class="line">    arrays[40];</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>顺序表用数组保存一系列的数据。</p><p>顺序表的特征</p><p>删除操作：<br><img src="http://upload-images.jianshu.io/upload_images/2005932-708eb8bd9e883573.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从上图中我们可以看出，当中间部位离去一个后，就会将该位置的后面的所有节点向前移一位。这是顺序表的删除操作。</p><p>中间插入操作：<br>     <img src="http://upload-images.jianshu.io/upload_images/2005932-443e56a912029dba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无标题.png"></p><p>如上图所示，我们将ax 插入到 a2 - a3 之间，就需要将 a2 之后的所有数据向后移动一位。</p><p>尾部插入：将非常简单直接在尾部插入就可以了。</p><blockquote><p>优点： 尾插效率高，支持随机访问。<br>缺点： 中间插入和删除效率低。<br>应用： ArrayList。 ArrayList 的底层实现便是对数组的操作。</p></blockquote><p>下面我们就分析一下 ArrayList 的源码</p><h4 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h4><h5 id="ArrayList-继承结构开始分析"><a href="#ArrayList-继承结构开始分析" class="headerlink" title="ArrayList 继承结构开始分析"></a>ArrayList 继承结构开始分析</h5><blockquote><p>public class ArrayList<e> extends AbstractList<e><br>implements List<e>, RandomAccess, Cloneable, java.io.Serializable</e></e></e></p></blockquote><ol><li>ArrayList  是继承于AbstractList。 </li></ol><blockquote><p>AbstractList<e> extends AbstractCollection<e> implements List<e><br>AbstractList 继承自AbstractCollection 抽象类，实现了list<br>接口，是ArrayList和AbstractSequentiaList 的父类,它实现了list 的一些位置相关的操作<br>(add,remove,get,set)<br>,是第一个实现随机访问的集合类，但不支持添加和替换，后续我们在分析AbstractList 源码。</e></e></e></p></blockquote><ol><li>ArrayList 实现list 接口能对它进行队列操作</li><li>ArrayList 实现了Cloneable接口，覆盖了函数clone()</li><li>ArrayList 实现了java.io.Serializable 接口，支持序列化，能通过序列化传输数据</li><li>ArrayList 实现了RandomAccess接口是List 实现所使用的标记接口，用来表明其支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。在对List特别的遍历算法中，要尽量来判断是属于RandomAccess(如ArrayList)还是SequenceAccess(如LinkedList），因为适合RandomAccess List的遍历算法，用在SequenceAccess List上就差别很大。</li></ol><h5 id="ArrayList-属性"><a href="#ArrayList-属性" class="headerlink" title="ArrayList 属性"></a>ArrayList 属性</h5><p>关键字transient 标识的字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。<br>我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。<br>然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。<br>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">        ArrayList的元素存储在其中的数组缓冲区。</span><br><span class="line">             ArrayList的容量是这个数组缓冲区的长度。当添加第一个元素时，任何具有elementData == EMPTY_ELEMENTDATA的空ArrayList将展开为DEFAULT_CAPACITY。</span><br><span class="line">私有包允许从java.util.Collections访问。</span><br><span class="line">     */</span><br><span class="line">    transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The size of the ArrayList (the number of elements it contains).</span><br><span class="line">     *</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">     * Default initial capacity.</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Shared empty array instance used for empty instances.</span><br><span class="line">     */</span><br><span class="line">    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>ArrayList 就是对数组进行 添加 删除 修改操作的，默认初始的容量 DEFAULT_CAPACITY = 10</p><h5 id="ArrayList-的构造函数"><a href="#ArrayList-的构造函数" class="headerlink" title="ArrayList 的构造函数"></a>ArrayList 的构造函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 定义容量 也就是数组的大小</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        super();</span><br><span class="line">        // 若传入的值小于0 抛出异常</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line"> initialCapacity);</span><br><span class="line">        //初始化数组</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认构造函数 初始化一个空的数组</span><br><span class="line">     */</span><br><span class="line">    public ArrayList() &#123;</span><br><span class="line">        super();</span><br><span class="line">        // private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造一个含有元素的列表</span><br><span class="line">     *</span><br><span class="line">     * @param c the collection whose elements are to be placed into this list</span><br><span class="line">     * @throws NullPointerException if the specified collection is null</span><br><span class="line">     */</span><br><span class="line">    public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        // 初始化含有元素的数组</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        // 数组的大小</span><br><span class="line">        size = elementData.length;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayList-添加元素"><a href="#ArrayList-添加元素" class="headerlink" title="ArrayList 添加元素"></a>ArrayList 添加元素</h5><h2 id="尾部添加"><a href="#尾部添加" class="headerlink" title="尾部添加"></a>尾部添加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        //进行完数组的自增长后才向数组中添加元素</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        //如果elementData 是个空数组 没有元素</span><br><span class="line">        if (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            //minCapacity 取DEFAULT_CAPACITY 和 minCapacity 的最大值 </span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    // 确保显式容量</span><br><span class="line">    private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        // overflow-conscious code minCapacity 必须大于数组的长度 才可自增长</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     // 实现数组的自增长</span><br><span class="line">     private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code 添加元素之前的数组长度</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        // 新的数组长度</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        // 若新的数组长度 小于 最小增长的数组长度,则 newCapacity = minCapacity</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        //数组长度达到最大值    </span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        //数组的最大长度</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        // minCapacity is usually close to size, so this is a win:</span><br><span class="line">        // 对数组进行copy 扩大数组的长度</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="中间插入-元素"><a href="#中间插入-元素" class="headerlink" title="中间插入 元素"></a>中间插入 元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">       if (index &gt; size || index &lt; 0)</span><br><span class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">       // 将插入元素 之后的数组后移一位 其实就是对数组的copy</span><br><span class="line">           src:源数组； </span><br><span class="line">           srcPos:源数组要复制的起始位置；</span><br><span class="line">           dest:目的数组；  </span><br><span class="line">           destPos:目的数组放置的起始位置；    l</span><br><span class="line">           ength:复制的长度。</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                        size - index);</span><br><span class="line">      // 向数组中添加元素</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>不管是尾部插入 还是中间插入 都会对数组进行copy 效率不高。</p></blockquote><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素 "></a>查找元素 </h2><p>非常简单并且效率 非常高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        if (index &gt;= size)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h2><p>非常简单并且效率 非常高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">       if (index &gt;= size)</span><br><span class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">       E oldValue = (E) elementData[index];</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       return oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>删除某个位置的元素 效率低<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        // 删除元素的位置必须大于或等于数组的大小</span><br><span class="line">        if (index &gt;= size)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        // 获取要删除的元素</span><br><span class="line">        E oldValue = (E) elementData[index];</span><br><span class="line">        //数据移动</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        // 若删除的不是最后一个</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            //对数组进行copy </span><br><span class="line">            src:源数组； </span><br><span class="line">            srcPos:源数组要复制的起始位置；</span><br><span class="line">            dest:目的数组；  </span><br><span class="line">            destPos:目的数组放置的起始位置；    l</span><br><span class="line">            ength:复制的长度。</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        // size - 1 前一位置空                     </span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">        // 返回删除的元素</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>同理 删除元素 效率低<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">       if (o == null) &#123;</span><br><span class="line">           for (int index = 0; index &lt; size; index++)</span><br><span class="line">               if (elementData[index] == null) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (int index = 0; index &lt; size; index++)</span><br><span class="line">               // 找到这个位置的元素</span><br><span class="line">               if (o.equals(elementData[index])) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    * Private remove method that skips bounds checking and does not</span><br><span class="line">    * return the value removed.</span><br><span class="line">    */</span><br><span class="line">   private void fastRemove(int index) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       int numMoved = size - index - 1;</span><br><span class="line">       if (numMoved &gt; 0)</span><br><span class="line">           System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>以上就是ArrayList 的核心方法，由此我们可以得出结论，顺序表最大的优点支持随机访问效率<br>很快，而最大的缺点就是 当数据量很大时，如果进行频繁的 删除 和 中间插入操作<br>将会非常慢 效率很低。在项目中要谨慎使用ArrayList</p></blockquote><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><blockquote><p>定义: 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组数据<br>元素可以是连续的，也可以是不连续的。</p><p>分类：<br>1： 单链表<br>2： 单循环链表<br>3： 双链表<br>4： 双向循环链表</p></blockquote><p>链表的模型类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="http://upload-images.jianshu.io/upload_images/2005932-bb945b185825dbbc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单链表.jpg"></p><p>如图所示: 每个节点都有一个数据域P-&gt;data 一个指针域 P-&gt; next -&gt; data 指针域指向的当前节点的下一个节点。</p><p>单链表 增加元素 –&gt; 中间插入<br><img src="http://upload-images.jianshu.io/upload_images/2005932-19e7f804feefe67f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单增.png"></p><p>如图所示，可以看出，如果我们在中间插入一个元素，只需要将 插入节点的 前一个节点的指针域 之前要插入的节点，而插入节点的指针域 之前 后一个指针域，这样的插入 比ArrayList 的插入效率要高很多。</p><p>同理如果需要尾部插入：只需要将最后一个节点的指针域 指向插入的节点。</p><p>单链表的删除操作</p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-6f95ffd565d27b39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单减.png"></p><p>如图所示： 如果要删除一个节点，只需要将 删除节点 的前一个节点的指针域 指向 删除节点的后一个节点。 这样删除要比 ArrayList的 删除效率要高很多。</p><blockquote><p>单链表的应用：<br>优点：头插，中间插，删除效率高。<br>缺点：不支持随机访问 （查找要进行循环的方式查找 效率低）<br>应用场景：<br>MessageQueue</p></blockquote><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p><img src="http://upload-images.jianshu.io/upload_images/2005932-c642dc23da016b45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双链表.jpg"></p><p>如图所示：  明白上述的单链表，那么双链表 就很好理解了，同理 双链表 比 单链表 多了一个指针域 这个指针域 指向的是 前一个节点。</p><p>双链表的插入操作</p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-d8547c0e6e3aabb2.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双向链表插入.JPG"></p><p>双链表的删除操作</p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-16b46b9b673212b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双链表删除.png"></p><p>下期： 深入理解链表和手写链表以及面试中的问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构之线性表&quot;&gt;&lt;a href=&quot;#数据结构之线性表&quot; class=&quot;headerlink&quot; title=&quot;数据结构之线性表&quot;&gt;&lt;/a&gt;数据结构之线性表&lt;/h1&gt;&lt;p&gt;在开始数据结构前，先了解什么是数据结构？数据结构 + 算法 = 程序&lt;/p&gt;
&lt;h2 id=&quot;数据结构的定义&quot;&gt;&lt;a href=&quot;#数据结构的定义&quot; class=&quot;headerlink&quot; title=&quot;数据结构的定义&quot;&gt;&lt;/a&gt;数据结构的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据结构是对在计算机内存中的数据的一种安排。也可以理解为对计算机运算的数据单元的一个抽&lt;br&gt;象。也可以理解为数据结构是指在计算机内存空间中或磁盘中的组织形式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据结构的定义描述的有些抽象，举个栗子：&lt;br&gt;&lt;img src=&quot;https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=120971917,3450162612&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;举个栗子&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://www.sufulu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="http://www.sufulu.top/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>hexo 搭建博客记录</title>
    <link href="http://www.sufulu.top/2018/01/13/hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.sufulu.top/2018/01/13/hexo-搭建博客记录/</id>
    <published>2018-01-13T04:21:35.000Z</published>
    <updated>2018-01-18T13:40:47.774Z</updated>
    
    <content type="html"><![CDATA[<p><a href="link"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;link&quot;&gt;&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="hexo" scheme="http://www.sufulu.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.sufulu.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.sufulu.top/2018/01/07/hello-world/"/>
    <id>http://www.sufulu.top/2018/01/07/hello-world/</id>
    <published>2018-01-07T02:04:27.750Z</published>
    <updated>2018-01-18T13:40:46.164Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a> </p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="Testing" scheme="http://www.sufulu.top/categories/Testing/"/>
    
    
      <category term="Testing" scheme="http://www.sufulu.top/tags/Testing/"/>
    
  </entry>
  
</feed>
