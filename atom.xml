<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Prim博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sufulu.top/"/>
  <updated>2018-01-29T15:29:25.526Z</updated>
  <id>http://www.sufulu.top/</id>
  
  <author>
    <name>Prim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构-线性表(顺序表与链表的基本知识 以及ArrayList 源码分析)</title>
    <link href="http://www.sufulu.top/2018/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://www.sufulu.top/2018/01/29/数据结构-线性表/</id>
    <published>2018-01-29T13:43:31.000Z</published>
    <updated>2018-01-29T15:29:25.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构之线性表"><a href="#数据结构之线性表" class="headerlink" title="数据结构之线性表"></a>数据结构之线性表</h1><p>在开始数据结构前，先了解什么是数据结构？数据结构 + 算法 = 程序</p><h2 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h2><blockquote><p>数据结构是对在计算机内存中的数据的一种安排。也可以理解为对计算机运算的数据单元的一个抽象。也可以理解为数据结构是指在计算机内存空间中或磁盘中的组织形式。</p></blockquote><p>数据结构的定义描述的有些抽象，举个栗子：<br><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=120971917,3450162612&amp;fm=27&amp;gp=0.jpg" alt="举个栗子"><br><a id="more"></a><br>比如：美女和野兽，抽象的事物表示美女：头发长 前凸后翘。。。 可以表示为一个数据单元，野兽也是一个数据单元。<br>我们可以这样理解，数据结构是描述个体的数据集合，包含两者的关系，数据与数据之前的关系，逻辑的结构。<br>比如：在人机对弈中，棋盘、棋子、人 三者的关系，棋盘存储起来  棋子是个单独的数据 人是个对象 三者之间的关系，错综复杂的关系组合起来就是数据结构。</p><h3 id="数据结构的逻辑结构"><a href="#数据结构的逻辑结构" class="headerlink" title="数据结构的逻辑结构"></a>数据结构的逻辑结构</h3><ol><li>集合结构</li><li>线性结构</li><li>树形结构</li><li>图形结构</li></ol><h3 id="数据结构的存储结构"><a href="#数据结构的存储结构" class="headerlink" title="数据结构的存储结构"></a>数据结构的存储结构</h3><ol><li>表</li><li>堆栈</li><li>队列</li><li>数据</li><li>树</li><li>二叉树</li><li>图</li></ol><p>了解了数据结构的基本内容，我们下面开始正题。</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ol><li>顺序存储结构</li><li>链式存储结构</li></ol><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>顺序存储结构可以理解为：<br>种菜，比如种萝卜，一个萝卜一个坑，从第一个一直按顺序种到最后一个。<br>再比如我们去银行办理业务，都要先取号排队，一个号都对应着一个人。<br>前后相关联的</p><p>如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-7dcb210ddaf6d1ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>a1是a2的前驱，ai+1 是ai的后继，a1没有前驱，an没有后继<br>n为线性表的长度 ，若n==0时，线性表为空表.</p><p>顺序表的类模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Array &#123;</span><br><span class="line">    arrays[40];</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>顺序表用数组保存一系列的数据。</p><p>顺序表的特征</p><p>删除操作：<br><img src="http://upload-images.jianshu.io/upload_images/2005932-708eb8bd9e883573.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从上图中我们可以看出，当中间部位离去一个后，就会将该位置的后面的所有节点向前移一位。这是顺序表的删除操作。</p><p>中间插入操作：<br>     <img src="http://upload-images.jianshu.io/upload_images/2005932-443e56a912029dba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无标题.png"></p><p>如上图所示，我们将ax 插入到 a2 - a3 之间，就需要将 a2 之后的所有数据向后移动一位。</p><p>尾部插入：将非常简单直接在尾部插入就可以了。</p><blockquote><p>优点： 尾插效率高，支持随机访问。<br>缺点： 中间插入和删除效率低。<br>应用： ArrayList。 ArrayList 的底层实现便是对数组的操作。</p></blockquote><p>下面我们就分析一下 ArrayList 的源码</p><h4 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h4><h5 id="ArrayList-继承结构开始分析"><a href="#ArrayList-继承结构开始分析" class="headerlink" title="ArrayList 继承结构开始分析"></a>ArrayList 继承结构开始分析</h5><blockquote><p>public class ArrayList<e> extends AbstractList<e><br>implements List<e>, RandomAccess, Cloneable, java.io.Serializable</e></e></e></p></blockquote><ol><li>ArrayList  是继承于AbstractList。 </li></ol><blockquote><p>AbstractList<e> extends AbstractCollection<e> implements List<e><br>AbstractList 继承自AbstractCollection 抽象类，实现了list<br>接口，是ArrayList和AbstractSequentiaList 的父类,它实现了list 的一些位置相关的操作<br>(add,remove,get,set)<br>,是第一个实现随机访问的集合类，但不支持添加和替换，后续我们在分析AbstractList 源码。</e></e></e></p></blockquote><ol><li>ArrayList 实现list 接口能对它进行队列操作</li><li>ArrayList 实现了Cloneable接口，覆盖了函数clone()</li><li>ArrayList 实现了java.io.Serializable 接口，支持序列化，能通过序列化传输数据</li><li>ArrayList 实现了RandomAccess接口是List 实现所使用的标记接口，用来表明其支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。在对List特别的遍历算法中，要尽量来判断是属于RandomAccess(如ArrayList)还是SequenceAccess(如LinkedList），因为适合RandomAccess List的遍历算法，用在SequenceAccess List上就差别很大。</li></ol><h5 id="ArrayList-属性"><a href="#ArrayList-属性" class="headerlink" title="ArrayList 属性"></a>ArrayList 属性</h5><p>关键字transient 标识的字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。<br>我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。<br>然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。<br>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">        ArrayList的元素存储在其中的数组缓冲区。</span><br><span class="line">             ArrayList的容量是这个数组缓冲区的长度。当添加第一个元素时，任何具有elementData == EMPTY_ELEMENTDATA的空ArrayList将展开为DEFAULT_CAPACITY。</span><br><span class="line">私有包允许从java.util.Collections访问。</span><br><span class="line">     */</span><br><span class="line">    transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The size of the ArrayList (the number of elements it contains).</span><br><span class="line">     *</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">     * Default initial capacity.</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Shared empty array instance used for empty instances.</span><br><span class="line">     */</span><br><span class="line">    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>ArrayList 就是对数组进行 添加 删除 修改操作的，默认初始的容量 DEFAULT_CAPACITY = 10</p><h5 id="ArrayList-的构造函数"><a href="#ArrayList-的构造函数" class="headerlink" title="ArrayList 的构造函数"></a>ArrayList 的构造函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 定义容量 也就是数组的大小</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        super();</span><br><span class="line">        // 若传入的值小于0 抛出异常</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line"> initialCapacity);</span><br><span class="line">        //初始化数组</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认构造函数 初始化一个空的数组</span><br><span class="line">     */</span><br><span class="line">    public ArrayList() &#123;</span><br><span class="line">        super();</span><br><span class="line">        // private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造一个含有元素的列表</span><br><span class="line">     *</span><br><span class="line">     * @param c the collection whose elements are to be placed into this list</span><br><span class="line">     * @throws NullPointerException if the specified collection is null</span><br><span class="line">     */</span><br><span class="line">    public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        // 初始化含有元素的数组</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        // 数组的大小</span><br><span class="line">        size = elementData.length;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayList-添加元素"><a href="#ArrayList-添加元素" class="headerlink" title="ArrayList 添加元素"></a>ArrayList 添加元素</h5><h2 id="尾部添加"><a href="#尾部添加" class="headerlink" title="尾部添加"></a>尾部添加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        //进行完数组的自增长后才向数组中添加元素</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        //如果elementData 是个空数组 没有元素</span><br><span class="line">        if (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            //minCapacity 取DEFAULT_CAPACITY 和 minCapacity 的最大值 </span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    // 确保显式容量</span><br><span class="line">    private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        // overflow-conscious code minCapacity 必须大于数组的长度 才可自增长</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     // 实现数组的自增长</span><br><span class="line">     private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code 添加元素之前的数组长度</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        // 新的数组长度</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        // 若新的数组长度 小于 最小增长的数组长度,则 newCapacity = minCapacity</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        //数组长度达到最大值    </span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        //数组的最大长度</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        // minCapacity is usually close to size, so this is a win:</span><br><span class="line">        // 对数组进行copy 扩大数组的长度</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="中间插入-元素"><a href="#中间插入-元素" class="headerlink" title="中间插入 元素"></a>中间插入 元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">       if (index &gt; size || index &lt; 0)</span><br><span class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">       // 将插入元素 之后的数组后移一位 其实就是对数组的copy</span><br><span class="line">           src:源数组； </span><br><span class="line">           srcPos:源数组要复制的起始位置；</span><br><span class="line">           dest:目的数组；  </span><br><span class="line">           destPos:目的数组放置的起始位置；    l</span><br><span class="line">           ength:复制的长度。</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                        size - index);</span><br><span class="line">      // 向数组中添加元素</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>不管是尾部插入 还是中间插入 都会对数组进行copy 效率不高。</p></blockquote><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素 "></a>查找元素 </h2><p>非常简单并且效率 非常高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        if (index &gt;= size)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h2><p>非常简单并且效率 非常高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">       if (index &gt;= size)</span><br><span class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">       E oldValue = (E) elementData[index];</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       return oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>删除某个位置的元素 效率低<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        // 删除元素的位置必须大于或等于数组的大小</span><br><span class="line">        if (index &gt;= size)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        // 获取要删除的元素</span><br><span class="line">        E oldValue = (E) elementData[index];</span><br><span class="line">        //数据移动</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        // 若删除的不是最后一个</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            //对数组进行copy </span><br><span class="line">            src:源数组； </span><br><span class="line">            srcPos:源数组要复制的起始位置；</span><br><span class="line">            dest:目的数组；  </span><br><span class="line">            destPos:目的数组放置的起始位置；    l</span><br><span class="line">            ength:复制的长度。</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        // size - 1 前一位置空                     </span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">        // 返回删除的元素</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>同理 删除元素 效率低<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">       if (o == null) &#123;</span><br><span class="line">           for (int index = 0; index &lt; size; index++)</span><br><span class="line">               if (elementData[index] == null) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (int index = 0; index &lt; size; index++)</span><br><span class="line">               // 找到这个位置的元素</span><br><span class="line">               if (o.equals(elementData[index])) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    * Private remove method that skips bounds checking and does not</span><br><span class="line">    * return the value removed.</span><br><span class="line">    */</span><br><span class="line">   private void fastRemove(int index) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       int numMoved = size - index - 1;</span><br><span class="line">       if (numMoved &gt; 0)</span><br><span class="line">           System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>以上就是ArrayList 的核心方法，由此我们可以得出结论，顺序表最大的优点支持随机访问效率<br>很快，而最大的缺点就是 当数据量很大时，如果进行频繁的 删除 和 中间插入操作<br>将会非常慢 效率很低。在项目中要谨慎使用ArrayList</p></blockquote><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><blockquote><p>定义: 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组数据<br>元素可以是连续的，也可以是不连续的。</p><p>分类：<br>1： 单链表<br>2： 单循环链表<br>3： 双链表<br>4： 双向循环链表</p></blockquote><p>链表的模型类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="http://upload-images.jianshu.io/upload_images/2005932-bb945b185825dbbc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单链表.jpg"></p><p>如图所示: 每个节点都有一个数据域P-&gt;data 一个指针域 P-&gt; next -&gt; data 指针域指向的当前节点的下一个节点。</p><p>单链表 增加元素 –&gt; 中间插入<br><img src="http://upload-images.jianshu.io/upload_images/2005932-19e7f804feefe67f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单增.png"></p><p>如图所示，可以看出，如果我们在中间插入一个元素，只需要将 插入节点的 前一个节点的指针域 之前要插入的节点，而插入节点的指针域 之前 后一个指针域，这样的插入 比ArrayList 的插入效率要高很多。</p><p>同理如果需要尾部插入：只需要将最后一个节点的指针域 指向插入的节点。</p><p>单链表的删除操作</p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-6f95ffd565d27b39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单减.png"></p><p>如图所示： 如果要删除一个节点，只需要将 删除节点 的前一个节点的指针域 指向 删除节点的后一个节点。 这样删除要比 ArrayList的 删除效率要高很多。</p><blockquote><p>单链表的应用：<br>优点：头插，中间插，删除效率高。<br>缺点：不支持随机访问 （查找要进行循环的方式查找 效率低）<br>应用场景：<br>MessageQueue</p></blockquote><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p><img src="http://upload-images.jianshu.io/upload_images/2005932-c642dc23da016b45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双链表.jpg"></p><p>如图所示：  明白上述的单链表，那么双链表 就很好理解了，同理 双链表 比 单链表 多了一个指针域 这个指针域 指向的是 前一个节点。</p><p>双链表的插入操作</p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-d8547c0e6e3aabb2.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双向链表插入.JPG"></p><p>双链表的删除操作</p><p><img src="http://upload-images.jianshu.io/upload_images/2005932-16b46b9b673212b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双链表删除.png"></p><p>下期： 深入理解链表和手写链表以及面试中的问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构之线性表&quot;&gt;&lt;a href=&quot;#数据结构之线性表&quot; class=&quot;headerlink&quot; title=&quot;数据结构之线性表&quot;&gt;&lt;/a&gt;数据结构之线性表&lt;/h1&gt;&lt;p&gt;在开始数据结构前，先了解什么是数据结构？数据结构 + 算法 = 程序&lt;/p&gt;
&lt;h2 id=&quot;数据结构的定义&quot;&gt;&lt;a href=&quot;#数据结构的定义&quot; class=&quot;headerlink&quot; title=&quot;数据结构的定义&quot;&gt;&lt;/a&gt;数据结构的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据结构是对在计算机内存中的数据的一种安排。也可以理解为对计算机运算的数据单元的一个抽象。也可以理解为数据结构是指在计算机内存空间中或磁盘中的组织形式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据结构的定义描述的有些抽象，举个栗子：&lt;br&gt;&lt;img src=&quot;https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=120971917,3450162612&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;举个栗子&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://www.sufulu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="http://www.sufulu.top/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>hexo 搭建博客记录</title>
    <link href="http://www.sufulu.top/2018/01/13/hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.sufulu.top/2018/01/13/hexo-搭建博客记录/</id>
    <published>2018-01-13T04:21:35.000Z</published>
    <updated>2018-01-18T13:40:47.774Z</updated>
    
    <content type="html"><![CDATA[<p><a href="link"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;link&quot;&gt;&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="hexo" scheme="http://www.sufulu.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.sufulu.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.sufulu.top/2018/01/07/hello-world/"/>
    <id>http://www.sufulu.top/2018/01/07/hello-world/</id>
    <published>2018-01-07T02:04:27.750Z</published>
    <updated>2018-01-18T13:40:46.164Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a> </p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="Testing" scheme="http://www.sufulu.top/categories/Testing/"/>
    
    
      <category term="Testing" scheme="http://www.sufulu.top/tags/Testing/"/>
    
  </entry>
  
</feed>
